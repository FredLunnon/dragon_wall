
// Dragon number-wall tiling for Littlewood, Magma, W.F.Lunnon (14/08/17) 
// dragon_wall.mag: see ANL.pdf etc, dragon_wall.tex, dragon_wall.pdf 
// Version: number-wall compatible with new tiling and [Lun01] !! 

////////////////////////////////////////////////////////////////////////////////

// Build rectangular number-wall from sequence: 
//   output determinant order-1  =  m  in range  mlo..mhi , 
//   output sequence index  n  in range  nlo..nhi , 
//   input sequence index  n  range  nlo-mhi..nhi+mhi , 
//   input order-1  mlo..mhi  range including  -2..0 . 
// Sequence: length odd, even for focus at entry, between entries resp.; 
//   entries should be field type, whether in integral domain. 

procedure NumberWall (~seq, mlo, mhi, nlo, nhi, ~wal) 
  local off,len,m,n,i,j,k,l,p,q,P,Q,R,S,d; 
  len := #seq; off := (len-(nhi-nlo+mhi+mhi+1))div 2;  // focus offset 
  assert mlo le -2 and mhi ge 0 and off ge 0; 
    // check depth sensible and sequence length sufficient 
  wal := [ [seq[1] : n in [nlo-mhi-2..nhi+mhi+2] ] : m in [mlo..mhi] ]; 
    // long wall of empty entries, typed as for sequence, subscript base = 1 

  for m in [mlo..mhi] do  // assign each entry in matrix order 
    for n in [nlo-mhi-2..nhi+mhi+2] do 
      i := m-mlo+1; j := n-nlo+mhi+3;  // rebased subscripts 

      if m lt -1 or ((n lt nlo-mhi-1 or n gt nhi+mhi+1) and m ne -1) then 
        wal[i,j] := 0; 
      elif m eq -1 or ((n eq nlo-mhi-1 or n eq nhi+mhi+1) and m gt -1) then 
        wal[i,j] := 1;  // initial sentinel windows 

      elif m eq 0 and n gt nlo-mhi-1 and n lt nhi+mhi+1 
      then wal[i,j] := seq[j-2+off];  // initial sequence 

      // compute entry ( m gt 0 and n gt nlo-mhi-1 and n lt nhi+mhi+1 ) 
      elif wal[i-2,j] ne 0 then  // zero-free case ( d = 0,1 ) 
        wal[i,j] := (wal[i-1,j]^2 - wal[i-1,j-1]*wal[i-1,j+1])/wal[i-2,j]; 

      elif wal[i-1,j] eq 0 then  // window interior ( wal[i-2,j] eq 0 ) 
        p := 0; while wal[i-p-1,j] eq 0 do p +:= 1; end while; 
        q := 1; while wal[i-p,j-q] eq 0 do q +:= 1; end while; 
        d := 1; while wal[i-p,j+d-q] eq 0 do d +:= 1; end while; 
          // window defic.  d  and pane offsets  p, q 

        if p lt d-1 then wal[i,j] := 0;  // window pane 
        else  // inner frame 
          wal[i,j] := (1 - (d-1)*(d-q)mod 2*2) * 
            wal[i-q,j-q]*wal[i-d+q,j+d-q]/wal[i-d,j+d-q-q]; end if; 

      else  // window exterior ( wal[i-2,j] eq 0 and wal[i-1,j] ne 0 ) 
        d := 1; while wal[i-1-d,j] eq 0 do d +:= 1; end while; 
        q := 1; while wal[i-d,j-q] eq 0 do q +:= 1; end while; 
          // window defic.  d  and pane offset  q 

        P := wal[i-d-1,j+d-q-q] / wal[i-d-1,j+d-q-q-1];  // frame ratios 
        Q := wal[i-q-1,j-q] / wal[i-q-2,j-q]; 
        R := wal[i-d+q-1,j+d-q] / wal[i-d+q,j+d-q]; 
        S := wal[i-1,j] / wal[i-1,j+1]; 

        wal[i,j] :=  // outer frame 
          wal[i-1,j] / R * (
            Q * wal[i-d-2,j+d-q-q] / wal[i-d-1,j+d-q-q] 
            + (1-(d-q)mod 2*2) * ( P * wal[i-q-1,j-q-1] / wal[i-q-1,j-q] 
              - S * wal[i-d+q-1,j+d-q+1] / wal[i-d+q-1,j+d-q] ) ); 
      end if; end for; end for; 

  wal := [ [ wal[i,j] : j in [mhi+3..nhi-nlo+mhi+3] ] : i in [1..mhi-mlo+1] ]; 
    // short wall: prune partial and sentinel columns from left and right 
end procedure; 

// Count number-wall deficiencies: 
//   output format  {* d^^e, ... *}  where  d,e = deficiency, frequency; 
//   for broken window  d = -1  (right or bottom only). 
procedure WallDeficiencies (~wal, mlo, mhi, nlo, nhi, ~mulset) 
  local m,n,i,j,k,l; 
  mulset := {* *};  // multiset of deficiencies 
  for m in [mlo..mhi-1] do  // each top left corner in wall 
    for n in [nlo..nhi-1] do 
      i := m-mlo+1; j := n-nlo+1;  // rebased subscripts 
      if wal[i, j] ne 0 then 
        if wal[i+1, j] eq 0 or wal[i, j+1] eq 0 then Include(~mulset, 0); 
        else  // nonzero deficiency 
        k := 1; while m+k lt mhi and wal[i+k, j+1] eq 0 do k := k+1; end while; 
        l := 1; while n+l lt nhi and wal[i+1, j+l] eq 0 do l := l+1; end while; 
        if m+k lt mhi or n+l lt nhi then Include(~mulset, Max(k,l)); 
        else Include(~mulset, -1); end if;  // broken window 
        end if; end if; 
      end for; end for; 
end procedure; 

////////////////////////////////////////////////////////////////////////////////

// Build overlapping inflation tiling of table by square tiles: 
//   entry location  [m, n]  range  [mlo..mhi, nlo..nhi]  focus at  [0, 0] ; 
//   tile square edge-length  tel , centre-interval  cid , both even; 
// Table: length odd, focus at table entry; return final encoding ~codes  and 
//   inflation child states  ~infls  indexed by state, mini-table  ~stab ; 
// Stabilised state indices: initial inflation  -> 1 2 3 4  or  -> 1 1 2 3 . 
// Assumes 2x2 inflation; structure  infls[s] and report max row & col maybe? 

procedure PlanarTiling (~tab, mlo, mhi, nlo, nhi, tel, cid, ~codes, ~infls, ~stab) 
  local dist,code,stalen,merp,perm, cid2,tel2,m,n,i,j,k,l,s,t,b,c; 

  // Pass 0: initialise 
  assert tel mod 2 eq 0 and cid mod 2 eq 0;  // tile widths even 
  assert mhi-mlo+1 eq #tab and nhi-nlo+1 eq #tab[1];  // table bounds match 
  cid2 := cid div 2; tel2 := tel div 2; 
  codes := {@ @};  // tile codes indexed by state 
  stab := [ [ 0 : n in [nlo div cid..nhi div cid] ] 
    : m in [mlo div cid..mhi div cid] ];  // mini-table of states 
  print "PlanarTiling() initial pass: parameters = ", 
    mlo, mhi, nlo, nhi, tel, cid; 

  // Pass 1: build codes list and mini-table of states 
  t := 0;  // current state count 
  for m in [mlo+tel2..mhi-tel2] do 
    for n in [nlo+tel2..nhi-tel2] do 
      if ( m mod cid eq cid2 and n mod cid eq cid2 ) then  // scan wall squares 

        i := m-mlo+1; j := n-nlo+1;  // rebase subscripts 
        code := [ [ tab[i+k, j+l] 
          : l in [-tel2..tel2] ] : k in [-tel2..tel2] ]; 
        s := Index(codes, code);  // state from code 
        if s eq 0 then // attach new tile 
          Include(~codes, code);  // set new code 
          t := t+1; s := t; end if; 
        i := 1 + m div cid - mlo div cid; 
        j := 1 + n div cid - nlo div cid;  // rebase subscripts 
        stab[i, j] := s;  // update mini-table 

      end if; end for; end for; 
  stalen := t;  // number of states 
  print "first pass: tile count = ", stalen; 

  // Pass 2: build inflation table, scanning states in mini-table 
  infls := [ [0, 0, 0, 0] : s in [1..stalen] ];  // daughters indexed by state; 
  for m in [Ceiling(mlo/2)+tel2+cid2+1..Floor(mhi/2)-tel2-cid2-1] do 
    for n in [Ceiling(nlo/2)+tel2+cid2+1..Floor(nhi/2)-tel2-cid2-1] do 
      if ( m mod cid eq cid2 and n mod cid eq cid2 ) then  // centre 

        i := 1 + m div cid - mlo div cid; 
        j := 1 + n div cid - nlo div cid;  // rebase subscripts 
        s := stab[i, j]; if s ne 0 then  // for each state 

          for h in [0..3] do 
            // Update partial inflation or check consistency 
            i := h div 2 + 2*m div cid - mlo div cid; 
            j := h mod 2 + 2*n div cid - nlo div cid;  // rebase subscripts 
            t := stab[i, j];  // daughter 
            if t eq 0 then 
              error "missing tile", s, t, h+1, infls[s]; 
            elif infls[s][h+1] eq 0 then 
              infls[s][h+1] := t;  // update inflation 
            elif infls[s][h+1] ne t then 
              error "inconsistent", s, t, h+1, infls[s];  // abort 
            end if; end for; 

        end if; end if; end for; end for; 
  print "second pass: inflation consistent"; 

  // Pass 3: check inflation closed 
  for s in [1..stalen] do  //  for each tile 
    if 0 in infls[s]  // unless all daughters set 
    then error "incomplete", s, infls[s];  // abort 
    end if; end for; 
  print "third pass: inflation complete"; 

  // Pass 4: stabilise state indices 
  b := 1.0*(mhi-mlo); c := 1.0*(nhi-nlo); 
  dist := [ b+c : s in [1..stalen] ];  // minimum norm indexed by state 
  for m in [mlo+tel2..mhi-tel2] do 
    for n in [nlo+tel2..nhi-tel2] do 
      if ( m mod cid eq cid2 and n mod cid eq cid2 ) then  // scan mini-table 
        i := 1 + m div cid - mlo div cid; 
        j := 1 + n div cid - nlo div cid;  // rebase subscripts 
        s := stab[i, j];  // update dist[s] 
        dist[s] := Min(dist[s], Abs(m) + Abs(n) + 0.1*m/b + 0.1*n/b/c);  
          // Manhatten distance from focus, row order, column order  
      end if; end for; end for; 

  perm := [ k : k in [1..stalen] ]; ParallelSort(~dist, ~perm); 
    // invert dist to perm 
  codes := [codes[perm[s]] : s in [1..stalen] ]; 
  infls := [ [ infls[perm[s]][h+1] : h in [0..3] ] : s in [1..stalen] ]; 
    // permute inflation and encoding indices 
  merp := [ k : k in [1..stalen] ]; ParallelSort(~perm, ~merp); 
    // invert perm to merp 
  infls := [ [ merp[infls[t][h+1]] : h in [0..3] ] : t in [1..stalen] ]; 
    // permute inflation values 
  merp := [ 0 ] cat merp; 
  stab := [ [ merp[s+1] : s in t ] : t in stab ]; 
  print "final pass: states stabilised"; 

end procedure; 

////////////////////////////////////////////////////////////////////////////////

// Explicit integer Rook/Dragon & signed Knight/Pagoda sequences: 
//   toggling  Rook(0) = 0,1  exchanges  Pago(+/-1) , else  Pago(n) = Pago(-n) ; 
function Dragon (n) 
  return (1-KroneckerSymbol(-1, n))/2; end function; 
function Dragon (n) 
  if n eq 0 then return 0; // alternatively,  return 1; 
  else while IsEven(n) do n := n div 2; end while; end if; 
  return n div 2 mod 2; end function; 
function Pagoda (n) 
  return Dragon(n+1) - Dragon(n-1); end function; 

////////////////////////////////////////////////////////////////////////////////

// Dragon square tiling validation: 2353 tiles in 5 min 
switch := true; time if switch then 
  mhi := 2340; nd2 := 5220;  // wall rows and cols/2 
  tel := 14; cid := 8;  // tile edge, centre distance 
  pad := Round((cid + tel)*5/2);  // sentinel rows 
  print "Dragon validation: rows, cols = ", mhi, 2*nd2+1; 
  seq := [ FiniteField(3) ! Dragon(j) : j in [-(nd2+mhi)..+(nd2+mhi)] ]; 
    // ternary Dragon, focussed centrally  
  NumberWall(~seq, -pad, mhi, -nd2, +nd2, ~wal); 
  WallDeficiencies(~wal, -pad, mhi, -nd2, +nd2, ~def); 
  print "deficiencies: ", def;  // { 0, 1, 2, 3, 4 } : window max 3x3 
  PlanarTiling(~wal, -pad, mhi, -nd2, +nd2, tel, cid, ~codes, ~infls, ~stawal); 
    // overlap tiling, focus as sequence 
end if; 

/* 
Dragon validation: rows, cols =  2340 10441
deficiencies:  {* -1, 0^^8637826, 1^^5650758, 2^^2227718, 3^^763987, 4^^188172 *}
PlanarTiling() initial pass: parameters =  -55 2340 -5220 5220 14 8
first pass: tile count =  2353
second pass: inflation consistent
third pass: inflation complete
final pass: states stabilised
Time: 300.700
*/ 

////////////////////////////////////////////////////////////////////////////////

// Pagoda square tiling construction & validation: 201/1201 tiles in 1.5 min 
switch := true; time if switch then 
  mhi := 1100; nd2 := 3000;  // wall rows and cols/2 
  tel := 12; cid := 8;  // tile edge, centre distance 
  pad := Round((cid + tel)*5/2);  // sentinel rows 
  print "Pagoda validation: rows, cols = ", mhi, 2*nd2+1; 
  seq := [ FiniteField(3) ! Pagoda(j) : j in [-(nd2+mhi)..+(nd2+mhi)] ]; 
    // ternary Pagoda, focussed centrally  
  NumberWall(~seq, -pad, mhi, -nd2, +nd2, ~wal); 
  WallDeficiencies(~wal, -pad, mhi, -nd2, +nd2, ~def); 
  print "deficiencies: ", def;  // { 1, 2 } : isolated zeros 
  PlanarTiling(~wal, -pad, +mhi, -nd2, +nd2, tel, cid, ~codes, ~infls, ~stawal); 
    // wide overlap, focus as sequence 
  print ""; print "Pagoda construction: rows, cols = ", mhi, 2*nd2+1; 
  tel := 8; cid := 8;  // tile edge, centre distance 
  PlanarTiling(~wal, 2-pad, 2+mhi, -nd2, +nd2, tel, cid, ~codes, ~infls, ~stawal); 
    // edge overlap, focus 2 rows up 
end if; 

/* 
Pagoda validation: rows, cols =  1100 6001
deficiencies:  {* -1, 0^^1981825, 1^^2642349, 2^^991425 *}
PlanarTiling() initial pass: parameters =  -48 1102 -3000 3000 12 8
first pass: tile count =  1201
second pass: inflation consistent
third pass: inflation complete
final pass: states stabilised

Pagoda construction: rows, cols =  1100 6001
PlanarTiling() initial pass: parameters =  -48 1102 -3000 3000 8 8
first pass: tile count =  201
second pass: inflation consistent
third pass: inflation complete
final pass: states stabilised

Time: 79.570
*/ 

////////////////////////////////////////////////////////////////////////////////

// Dragon wall-tiling: sequence canonical states  [0..7] 
//   correspond to wall states  [ 2, 13, 7, 12, 20, 6, 1, 29 ] 

// Locate & extract sequence tile rows among Dragon 3561-tile wall squares 
//sel := 16; cid := 8; wot := -1;  // focal shift wall-to-table 
sel := 14; cid := 8; wot := +1;  // focal shift wall-to-table 
oll := (sel-cid)div 2;  // overlap = 4 

sequ_states := [ s  : s in [1..#codes] | 
  forall(entry){ entry : entry in [ code[i,j] : j in [1..sel], i in [1..sel-oll-wot-1] ] 
    | entry eq 0 } where code := codes[s] ]; 
// sequ_states := SequenceToSet(stawal[1 + p div 8]) diff { 0 };  // easier! 
sequ_states; 
[ infl[3..4] : infl in [ infls[s] : s in sequ_states ] ]; // raw inflation 
crows := [ code[(sel+cid)div 2-wot+2][1+oll..1+sel-oll] : code in [ codes[s] : s in sequ_states ] ]; crows; 

// Canonical state bits c0,c1,c2 = bits 9,5,1 , cast to integer! 
IR := IntegerRing(); 
[ [ (IR!row[1+cid] + 2*IR!row[1+cid div 2] + 4*IR!row[1]), sequ_states[s] ] : s in [1..#crows] | 
  exists(entry){ entry : entry in row | entry ne 0 } where row := crows[s] ]; 

// Permute in order of canonical states 
scan := [ (IR!row[1+cid] + 2*IR!row[1+cid div 2] + 4*IR!row[1]) : s in [1..#crows] | 
  exists(entry){ entry : entry in row | entry ne 0 } where row := crows[s] ]; 
swal := [ sequ_states[s] : s in [1..#crows] | 
  exists(entry){ entry : entry in row | entry ne 0 } where row := crows[s] ]; 
ParallelSort(~scan, ~swal); swal; 

/* 
> 
> // Dragon wall-tiling: sequence canonical states  [0..7] 
> //   correspond to wall states  [ 2, 13, 7, 12, 20, 6, 1, 29 ] 
> 
> // Locate & extract sequence tile rows among Dragon 3561-tile wall squares 
> //sel := 16; cid := 8; wot := -1;  // focal shift wall-to-table, <= 0 ! 
> sel := 14; cid := 8; wot := +1;  // focal shift wall-to-table, <= 0 ! 
> oll := (sel-cid)div 2;  // overlap = 4 
> 
> sequ_states := [ s  : s in [1..#codes] | 
>   forall(entry){ entry : entry in [ code[i,j] : j in [1..sel], i in [1..sel-\
oll-wot-1] ] 
>     | entry eq 0 } where code := codes[s] ];  
> sequ_states; 
[ 1, 2, 5, 6, 7, 12, 13, 20, 29 ]
> [ infl[3..4] : infl in [ infls[s] : s in sequ_states ] ]; // raw inflation 
[
    [ 6, 1 ],
    [ 2, 7 ],
    [ 5, 5 ],
    [ 20, 12 ],
    [ 13, 1 ],
    [ 13, 29 ],
    [ 2, 12 ],
    [ 20, 7 ],
    [ 6, 29 ]
]
> crows := [ code[(sel+cid)div 2-wot+2][1+oll..1+sel-oll] : code in [ codes[s]\
 : s in sequ_states ] ]; crows; 
[
    [ 1, 0, 0, 1, 1, 0, 1, 1, 0 ],
    [ 0, 0, 0, 1, 0, 0, 1, 1, 0 ],
    [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
    [ 1, 0, 0, 1, 0, 0, 1, 1, 1 ],
    [ 0, 0, 0, 1, 1, 0, 1, 1, 0 ],
    [ 0, 0, 0, 1, 1, 0, 1, 1, 1 ],
    [ 0, 0, 0, 1, 0, 0, 1, 1, 1 ],
    [ 1, 0, 0, 1, 0, 0, 1, 1, 0 ],
    [ 1, 0, 0, 1, 1, 0, 1, 1, 1 ]
]
> 
> // Canonical state bits c0,c1,c2 = bits 9,5,1 , cast to integer! 
> IR := IntegerRing(); 
> [ [ (IR!row[1+cid] + 2*IR!row[1+cid div 2] + 4*IR!row[1]), sequ_states[s] ] \
: s in [1..#crows] | 
>   exists(entry){ entry : entry in row | entry ne 0 } where row := crows[s] ]\
; 
[
    [ 6, 1 ],
    [ 0, 2 ],
    [ 5, 6 ],
    [ 2, 7 ],
    [ 3, 12 ],
    [ 1, 13 ],
    [ 4, 20 ],
    [ 7, 29 ]
]
> 
> // Permute in order of canonical states 
> scan := [ (IR!row[1+cid] + 2*IR!row[1+cid div 2] + 4*IR!row[1]) : s in [1..#\
crows] | 
>   exists(entry){ entry : entry in row | entry ne 0 } where row := crows[s] ]\
; 
> swal := [ sequ_states[s] : s in [1..#crows] | 
>   exists(entry){ entry : entry in row | entry ne 0 } where row := crows[s] ]\
; 
> ParallelSort(~scan, ~swal); swal; 
[ 2, 13, 7, 12, 20, 6, 1, 29 ]
> 
*/ 

////////////////////////////////////////////////////////////////////////////////

// Dragon wall tiling: Mini-table for Figure \label{[statseg]} 
// Warning: states assigned in matrix order not Manhattan if aborted! 
   k_ := 11; n_ := #stawal[1] div 2 + 1; // approximate centre! 
   [ [ stawal[i, j] : j in [n_-k_..n_+k_-1] ] : i in [p div 8 -1..p div 8 -1+k_] ]; 

// Wall segment to file [wallseg.txt] for Figure \label{[wallseg]} 
   k_ := 40; n_ := #wal[1] div 2 + 1; // approximate centre! 
   [ [ wal[i, j] : j in [n_-k_..n_+k_] ] : i in [p..p+k_+1] ]; 

s := 17;  // highlighted state: inflation, NW-NE-SW-SE ;  
infls[s]; // [ 35, 45, 47, 58 ] , centres (20,20) , ... , (28,28) 
codes[s];  // highlighted square centred at m,n = (12,12) 

/* 
// 14x14 tile, tiles 2353 
[
    [ 1, 0, 1, 2, 1, 2, 1, 2, 0, 2, 1, 2, 1, 2, 1 ],
    [ 1, 2, 1, 2, 2, 0, 0, 2, 1, 2, 0, 2, 1, 2, 0 ],
    [ 1, 0, 0, 1, 1, 0, 0, 2, 0, 2, 2, 2, 0, 2, 1 ],
    [ 1, 0, 0, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2 ],
    [ 1, 1, 1, 1, 0, 1, 2, 0, 2, 1, 0, 1, 2, 0, 2 ],
    [ 1, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2 ],
    [ 2, 2, 0, 2, 2, 2, 1, 0, 1, 0, 2, 0, 1, 0, 1 ],
    [ 0, 2, 1, 2, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2 ],
    [ 1, 2, 0, 2, 2, 2, 2, 2, 0, 2, 0, 2, 0, 2, 0 ],
    [ 1, 2, 2, 2, 2, 0, 0, 2, 1, 2, 1, 2, 1, 2, 1 ],
    [ 1, 1, 0, 0, 2, 0, 0, 2, 1, 0, 1, 0, 2, 0, 0 ],
    [ 1, 2, 0, 0, 2, 2, 2, 2, 1, 1, 1, 2, 1, 0, 0 ],
    [ 0, 1, 2, 1, 2, 1, 0, 1, 2, 0, 2, 1, 2, 1, 2 ],
    [ 2, 2, 2, 1, 0, 2, 1, 2, 1, 2, 1, 0, 0, 1, 1 ],
    [ 0, 0, 1, 1, 2, 1, 1, 0, 0, 2, 2, 0, 0, 1, 1 ]
];  
*/ 

/* 
// wallseg.txt with  m,l = 10,10 (now 40,40) 
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
     1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0,
     1, 0, 1, 0, 0, 1, 1, 2, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0,
     1, 2, 1, 1, 1, 1, 2, 2, 2, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0,
     2, 2, 2, 2, 0, 2, 2, 0, 2, 1, 2, 1, 2, 1, 2, 1, 0, 1, 2, 1, 2,
     1, 0, 0, 1, 2, 1, 2, 1, 2, 0, 2, 1, 2, 0, 0, 1, 2, 1, 2, 2, 0,
     2, 0, 0, 2, 1, 0, 0, 1, 2, 2, 2, 0, 2, 0, 0, 1, 0, 0, 1, 1, 0,
     1, 1, 1, 1, 2, 0, 0, 1, 1, 1, 2, 2, 2, 1, 2, 1, 0, 0, 2, 2, 2,
     1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1,
     1, 2, 1, 0, 0, 1, 1, 1, 2, 1, 0, 0, 0, 1, 1, 1, 2, 2, 2, 1, 2,
     0, 2, 1, 0, 0, 1, 0, 2, 0, 1, 0, 0, 0, 1, 2, 2, 2, 0, 2, 2, 2,
*/ 

// stawal with  k_ = 11, tiles 3561 
[
    [   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5 ], 
    [  12,   6,  29,  20,   7,  13,  29,  20,  12,   6,   1, . 2,   7,  13,   1,   2,  12,   6,   1,   2,   7,  13 ], 
    [  41,  96,  80,  65,  52,  40,  30,  21,  14,   8,   3,   4,   9,  15,  22,  31,  41,   8,   3,   4,   9,  40 ], 
    [ 134, 114,  97,  81,  66,  53,  42,  32,  23,  16,  10,  11,  17,  24,  33,  43,  54,  67,  10,  11, 115, 135 ], 
    [ 156, 136, 116,  98,  82,  68,  55,  44,  34,  25,  18,  19,  26,  35,  45,  56,  69,  83,  99, 117, 137, 157 ], 
    [ 180, 158, 138, 118, 100,  84,  70,  57,  46,  36,  27,  28,  37,  47,  58,  71,  85, 101, 119, 139, 159, 181 ], 
    [ 206, 182, 160, 140, 120, 102,  86,  72,  59,  48,  38,  39,  49,  60,  73,  87, 103, 121, 141, 161, 183, 207 ], 
    [ 234, 208, 184, 162, 142, 122, 104,  88,  74,  61,  50,  51,  62,  75,  89, 105, 123, 143, 163, 185, 209, 235 ], 
    [ 261, 236, 210, 186, 164, 144, 124, 106,  90,  76,  63,  64,  77,  91, 107, 125, 145, 165, 187, 211, 237, 262 ], 
    [ 289, 263, 238, 212, 188, 166, 146, 126, 108,  92,  78,  79,  93, 109, 127, 147, 167, 189, 213, 239, 264, 290 ], 
    [  86,  72, 265, 240, 214, 190, 168, 148, 128, 110,  94,  95, 111, 129, 149, 169, 191, 215, 241, 266, 291, 318 ], 
    [ 104,  88, 292, 267, 242, 216, 192, 170, 150, 130, 112, 113, 131, 151, 171, 193, 217, 243, 268, 293, 319, 349 ] 
]; 

// stawal with  k_ = 11, tiles 2353 
[
    [ 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 ],
    [ 12, 6, 29, 20, 7, 13, 29, 20, 12, 6, 1, 2, 7, 13, 1, 2, 12, 6, 1, 2, 7, 13 ],
    [ 41, 96, 80, 65, 52, 40, 30, 21, 14, 8, 3, 4, 9, 15, 22, 31, 41, 8, 3, 4, 9, 40 ],
    [ 134, 114, 97, 81, 66, 53, 42, 32, 23, 16, 10, 11, 17, 24, 33, 43, 54, 67, 10, 11, 115, 135 ],
    [ 156, 136, 116, 98, 82, 68, 55, 44, 34, 25, 18, 19, 26, 35, 45, 56, 69, 83, 99, 117, 137, 157 ],
    [ 179, 158, 138, 118, 100, 84, 70, 57, 46, 36, 27, 28, 37, 47, 58, 71, 85, 101, 119, 139, 159, 180 ],
    [ 204, 181, 160, 140, 120, 102, 86, 72, 59, 48, 38, 39, 49, 60, 73, 87, 103, 121, 141, 161, 182, 205 ],
    [ 230, 206, 183, 162, 142, 122, 104, 88, 74, 61, 50, 51, 62, 75, 89, 105, 123, 143, 163, 184, 207, 231 ],
    [ 256, 232, 208, 185, 164, 144, 124, 106, 90, 76, 63, 64, 77, 91, 107, 125, 145, 165, 186, 209, 233, 257 ],
    [ 70, 258, 234, 210, 105, 166, 146, 126, 108, 92, 78, 79, 93, 109, 127, 147, 167, 187, 211, 235, 259, 283 ],
    [ 86, 72, 260, 236, 212, 188, 168, 148, 128, 110, 94, 95, 111, 129, 149, 169, 189, 213, 237, 261, 284, 308 ],
    [ 104, 88, 285, 262, 238, 214, 190, 170, 150, 130, 112, 113, 131, 151, 171, 191, 215, 239, 263, 286, 309, 337 ]
]; 

////////////////////////////////////////////////////////////////////////////////

// Inflation morphism is invariant under focus [0,0] or [-2,0] ! 
  PlanarTiling(~wal, -p, +m, 0, n, 14, 8, ~codes, ~infls, ~stawal);  // overlap tiling 
  PlanarTiling(~wal, -2-p, -2+m, -l, +l, 14, 8, ~codes2, ~infls2, ~stawal2);  // overlap tiling, focus up 2 rows 
infls eq infls0;  // true

////////////////////////////////////////////////////////////////////////////////

// State statistics by row: odd and even row are always disjoint! 
imax := 20; 
starows := [ SequenceToMultiset(stawal[i+ p div 8]) diff {* 0^^4 *} : i in [0..imax] ]; starows; 
// later frequencies = ~5, 10, 15 maybe? 
starows := [ SequenceToSet(stawal[i+ p div 8]) diff { 0 } : i in [0..imax] ]; 
[ [ #(starows[i+1] meet starows[j+1]) : j in [0..i-1] ] : i in [0..imax] ]; 
[
    [],
    [ 0 ],
    [ 0, 0 ],
    [ 0, 0, 0 ],
    [ 0, 0, 0, 0 ],
    [ 0, 0, 0, 0, 0 ],
    [ 0, 0, 0, 0, 0, 0 ],
    [ 0, 0, 0, 0, 0, 0, 0 ],
    [ 0, 0, 0, 0, 0, 0, 0, 0 ],
    [ 0, 0, 0, 0, 0, 4, 0, 4, 0 ],
    [ 0, 0, 0, 0, 4, 0, 6, 0, 4, 0 ],
    [ 0, 0, 0, 0, 0, 4, 0, 4, 0, 2, 0 ],
    [ 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0 ],
    [ 0, 0, 0, 0, 0, 14, 0, 0, 0, 4, 0, 4, 0 ],
    [ 0, 0, 0, 0, 0, 0, 18, 0, 2, 0, 8, 0, 0, 0 ],
    [ 0, 0, 0, 0, 0, 0, 0, 12, 0, 14, 0, 14, 0, 0, 0 ],
    [ 0, 0, 0, 0, 8, 0, 4, 0, 12, 0, 16, 0, 16, 0, 0, 0 ],
    [ 0, 0, 0, 0, 0, 22, 0, 6, 0, 16, 0, 4, 0, 24, 0, 0, 0 ],
    [ 0, 0, 0, 0, 0, 0, 28, 0, 4, 0, 18, 0, 0, 0, 28, 0, 6, 0 ],
    [ 0, 0, 0, 0, 0, 0, 0, 24, 0, 14, 0, 18, 0, 0, 0, 30, 0, 10, 0 ],
    [ 0, 0, 0, 0, 14, 0, 0, 0, 22, 0, 24, 0, 16, 0, 0, 0, 36, 0, 8, 0 ]
]; 
// row 9 has 4 states in common with each row 5, 7 
i := 9; j := 5; starows[i+1] meet starows[j+1]; 
{ 70, 84, 85, 283 }; 
i := 9; j := 7; starows[i+1] meet starows[j+1]; 
{ 89, 105, 690, 728 }; 
[ #starows[i+1] : i in [0..imax] ]; 
[ 1, 8, 16, 24, 32, 40, 48, 56, 64, 72, 78, 86, 90, 94, 104, 114, 124, 128, 134, 142, 146 ]; 
[ #(SequenceToSet(stawal[i]) diff { 0 }) : i in [290..300] ]; 
[ 301, 263, 270, 362, 412, 364, 364, 408, 356, 259, 249 ]; 
  // no longer monotonic, so probably incomplete? 

////////////////////////////////////////////////////////////////////////////////

